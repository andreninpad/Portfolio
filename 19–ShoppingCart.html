<!--Learn Basic OOP by Building a Shopping Cart. OOP, or Object Oriented Programming, is one of the major approaches to the software development process. In OOP, developers use objects and classes to structure their code. Learn how to define classes and use them. Create class instances and implement methods for data manipulation. This will cover concepts like the ternary operator, the spread operator, the this keyword, and more.-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="../HTML&CSS/Images/anp.svg" type="image/x-icon">
  <title>Shopping Cart</title>
  <style>
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --dark-grey: #1b1b32;
      --light-grey: #f5f6f7;
      --black: #000;
      --white: #fff;
      --grey: #3b3b4f;
      --golden-yellow: #fecc4c;
      --yellow: #ffcc4c;
      --gold: #feac32;
      --orange: #ffac33;
      --dark-orange: #f89808;
    }
    body {background-color: var(--dark-grey);}
    .title {
      color: var(--light-grey);
      text-align: center;
      margin: 25px 0;
    }
    #dessert-card-container {
      display: flex;
      flex-direction: column;
      flex-wrap: wrap;
      align-items: center;
    }
    .dessert-card {
      background-color: var(--light-grey);
      padding: 15px;
      text-align: center;
      border-radius: 15px;
      margin: 20px 10px;
    }
    .dessert-price {font-size: 1.2rem;}
    .btn {
      cursor: pointer;
      width: 100px;
      color: var(--dark-grey);
      background-color: var(--gold);
      background-image: linear-gradient(var(--golden-yellow), var(--orange));
      border-color: var(--gold);
      border-width: 3px;
    }
    .btn:hover {background-image: linear-gradient(var(--yellow), var(--dark-orange));}
    #cart-btn {
      position: absolute;
      top: 0;
      right: 0;
    }
    .add-to-cart-btn {margin: 30px auto 10px;}
    #cart-container {
      position: absolute;
      top: 60px;
      right: 0;
      background-color: var(--light-grey);
      width: 200px;
      height: 400px;
      border: 8px double var(--black);
      border-radius: 15px;
      text-align: center;
      font-size: 1.2rem;
      overflow-y: scroll;
    }
    .product {margin: 25px 0;}
    .product-count {
      display: inline-block;
      margin-right: 10px;
    }
    .product-category {margin: 10px 0;}
    @media (min-width: 768px) {
      #dessert-card-container {flex-direction: row}
      .dessert-card {flex: 1 0 21%}
      #cart-container {width: 300px}
    }
  </style>
</head>
<body>
  <header><h1 class="title">Desserts Page</h1></header>
  <main>
    <button id="cart-btn" type="button" class="btn">
      <span id="show-hide-cart">Show</span> Cart
    </button>
    <div id="cart-container" hidden>
      <button class="btn" id="clear-cart-btn">Clear Cart</button>
      <div id="products-container"></div>
      <p>Total number of items: <span id="total-items">0</span></p>
      <p>Subtotal: <span id="subtotal">$0</span></p>
      <p>Taxes: <span id="taxes">$0</span></p>
      <p>Total: <span id="total">$0</span></p>
    </div>
    <div id="dessert-card-container"></div>
  </main>
</body>
<script>
const cartContainer = document.getElementById('cart-container');
const productsContainer = document.getElementById('products-container');
const dessertCards = document.getElementById('dessert-card-container');
const cartBtn = document.getElementById('cart-btn');
const clearCartBtn = document.getElementById('clear-cart-btn');
const totalNumberOfItems = document.getElementById('total-items');
const cartSubTotal = document.getElementById('subtotal');
const cartTaxes = document.getElementById('taxes');
const cartTotal = document.getElementById('total');
const showHideCartSpan = document.getElementById('show-hide-cart');
let isCartShowing = false;
const products = [
  {id: 1, name: 'Vanilla Cupcakes (6 Pack)', price: 12.99, category: 'Cupcake'},
  {id: 2, name: 'French Macaron', price: 3.99, category: 'Macaron'},
  {id: 3, name: 'Pumpkin Cupcake', price: 3.99, category: 'Cupcake'},
  {id: 4, name: 'Chocolate Cupcake', price: 5.99, category: 'Cupcake'},
  {id: 5, name: 'Chocolate Pretzels (4 Pack)', price: 10.99, category: 'Pretzel'},
  {id: 6, name: 'Strawberry Ice Cream', price: 2.99, category: 'Ice Cream'},
  {id: 7, name: 'Chocolate Macarons (4 Pack)', price: 9.99, category: 'Macaron'},
  {id: 8, name: 'Strawberry Pretzel', price: 4.99, category: 'Pretzel'},
  {id: 9, name: 'Butter Pecan Ice Cream', price: 2.99, category: 'Ice Cream'},
  {id: 10, name: 'Rocky Road Ice Cream', price: 2.99, category: 'Ice Cream'},
  {id: 11, name: 'Vanilla Macarons (5 Pack)', price: 11.99, category: 'Macaron'},
  {id: 12, name: 'Lemon Cupcakes (4 Pack)', price: 12.99, category: 'Cupcake'}
]; //Using an array will allow to store multiple products. A product will need a unique identifier to distinguish it from other products, a price so people know how much it costs, and a name so people know what they are buying. Should also add a category to each product.
products.forEach(({name, id, price, category}) => {
  dessertCards.innerHTML += `<div class="dessert-card">
    <h2>${name}</h2>
    <p class="dessert-price">$${price}</p>
    <p class="product-category">Category: ${category}</p>
    <button id="${id}" class="btn add-to-cart-btn">Add to cart</button>
  </div>`; //Use the addition assignment operator to add an empty template literal string to the innerHTML property of the dessertCards variable.
}); //For the first parameter of callback function, destructure the name, id, price, and category properties from the object passed in.

class ShoppingCart {
  constructor() {
    this.items = [];
    this.total = 0;
    this.taxRate = 8.25; //The this keyword in JavaScript is used to refer to the current object. Depending on where this is used, what it references changes. In the case of a class, it refers to the instance of the object being constructed. You can use the this keyword to set the properties of the object being instantiated. Here is an example: class Computer { constructor() { this.ram = 16; }; };
  }; //Classes have a special constructor method, which is called when a new instance of the class is created. The constructor method is a great place to initialize properties of the class. Here is an example of a class with a constructor method: class Computer { constructor() {} }
  addItem(id, products) {
    const product = products.find(item => item.id === id); //Need to find the product that the user is adding to the cart. Remember that arrays have a .find() method. In addItem function, declare a product variable, and assign it the value of calling the .find() method on the products array. For the callback to .find(), pass a function that takes a single parameter item, and returns whether the id property of item is strictly equal to the id parameter passed to addItem.
    const {name, price} = product; //Use const and destructuring to extract name and price variables from product.
    this.items.push(product); //Need to push the product into the cart's items array, use the this keyword.
    const totalCountPerProduct = {}; //Need a total count of each product that the user has in the cart.
    this.items.forEach(dessert => {
      totalCountPerProduct[dessert.id] = (totalCountPerProduct[dessert.id] || 0) + 1; //In forEach callback, update the totalCountPerProduct object. Using the id of the current dessert as property, update the value of the property to be the current value plus one. There's a small bug. When trying to access a property of an object and the property doesn't exist, it is undefined. This means if the dessert isn't already present in the totalCountPerProduct object, it ended up trying to add 1 to undefined, which results in NaN. To fix this, use the || operator to set the value to 0 if it doesn't exist. Wrap the right-hand totalCountPerProduct[dessert.id] in parentheses, and add || 0 to the end of the expression.
    }); //Use the .forEach() method to loop through the items array.
    const currentProductCount = totalCountPerProduct[product.id]; //To get prepared to update the display with the new product the user added.
    const currentProductCountSpan = document.getElementById(`product-count-for-id${product.id}`); //Haven't written the code to generate the HTML yet, but if a product has already been added to the user's cart then there will be a needed matching element.
    currentProductCount > 1 ? currentProductCountSpan.textContent = `${currentProductCount}x` : productsContainer.innerHTML += `<div class="product" id="dessert${id}">
      <p><span class="product-count" id="product-count-for-id${id}">${name}</span></p>
      <p>${price}</p>
    </div>`; //Checks if the current product is already in the cart. The behaviour of the addItem method needs to change if the product is already in the cart or not.
  }; //ShoppingCart class needs the ability to add items. Create an empty addItem method, which takes two parameters: id and products.
  getCounts() {return this.items.length;}; //The best way to access the total number of items in the cart is to add another method to ShoppingCart class, rather than accessing the items array directly. Add a getCounts method to the ShoppingCart class. It should return the number of items in the items array.
  clearCart() {
    if (!this.items.length) {
      alert("Your shopping cart is already empty");
      return;
    } //Check if the items array is empty. If it is, display an alert to the user, then return from the function to stop execution. Remember that 0 is a falsy value, so use the ! operator to check if the array is empty.
    else {const isCartCleared = confirm('Are you sure you want to clear all items from your shopping cart?');
      if (isCartCleared) {
        this.items = []; //Set the items property back to an empty array
        this.total = 0; //Set the total property to 0.
        productsContainer.innerHTML = ''; //Set the innerHTML property of the productsContainer back to an empty string.
        totalNumberOfItems.textContent = 0; //Set the textContent of the totalNumberOfItems element to 0.
        cartSubTotal.textContent = 0; //Set the textContent of the cartSubTotal element to 0.
        cartTaxes.textContent = 0; //Set the textContent of the cartTaxes element to 0.
        cartTotal.textContent = 0; //Set the textContent of the cartTotal element to 0.
      }; //To clear the cart if the prompt is confirmed.
    }; //Browsers have a built-in confirm() function which displays a confirmation prompt. The confirm() accepts a string, which is the message displayed. It returns true if confirms, and false if cancels.
  }; //To be able to clear the cart.
  calculateTaxes(amount) {return parseFloat(((this.taxRate / 100) * amount).toFixed(2));}; //To calculate taxes. Return the value of the taxRate (divided by 100, to convert it to a percent) multiplied by the amount parameter. Wrap the calculation in parentheses and call the .toFixed() method on it. Pass the .toFixed() method the number 2 as an argument. This will round the number to two decimal places and return a string. Pass the .toFixed() call (including the calculation) to the parseFloat() function to convert the fixed string back into a number, preserving the existing decimal places.
  calculateTotal() {
    const subTotal = this.items.reduce((total, item) => total + item.price, 0); //Declare a subTotal variable and use the reduce method on the items array to calculate the sum of the price property of each item in the array. Use total and item as the parameters for the callback, also set the initial value in the reduce method.
    const tax = this.calculateTaxes(subTotal); //Declare a variable tax and assign it the value of calling .calculateTaxes() method, passing subTotal as the argument.
    this.total = subTotal + tax; //The total value is the sum of the subTotal and tax values.
    cartSubTotal.textContent = `$${subTotal.toFixed(2)}`; //To update the HTML, set the textContent of the cartSubTotal to be the value of subTotal to a fixed 2 decimal places. Use template literal syntax to add the dollar sign to the beginning of the value.
    cartTaxes.textContent = `$${tax.toFixed(2)}`;
    cartTotal.textContent = `$${this.total.toFixed(2)}`;
    return this.total; //Use the this keyword to return the value of the total property.
  }; //Create a calculateTotal method in the ShoppingCart class to update the total price of the cart when the user adds an item.
}; //A class is like a blueprint for creating objects. To define a set of properties and methods, and instantiate or create new objects with those properties and methods. The class keyword is used to declare a class. Here is an example of declaring a Computer class: class Computer {};

const cart = new ShoppingCart(); //There is still more functionality that ShoppingCart class needs, but first it need to be able to test the code that currently written. To instantiate a new ShoppingCart object and assign it to a variable. Here is an example of instantiating the Computer class from earlier examples: const myComputer = new Computer();
const addToCartBtns = document.getElementsByClassName('add-to-cart-btn'); //To get all of the Add to cart buttons that are added to the DOM earlier.

[...addToCartBtns].forEach(btn => {
  btn.addEventListener('click', event => {
    cart.addItem(Number(event.target.id), products); //call the .addItem() method of cart object, and pass in the event.target.id. The id here will be a string, so convert it to a number. Pass products array as the second argument.
    totalNumberOfItems.textContent = cart.getCounts(); //Assign the value of the cart object's .getCounts() method to the textContent of the totalNumberOfItems variable.
    cart.calculateTotal(); //Call .calculateTotal() method inside forEach loop.
  });
}); //Use the spread operator on the addToCartBtns variable to convert it into an array. Then, use the forEach method to iterate through the array.

cartBtn.addEventListener('click', () => {
  isCartShowing = !isCartShowing //Invert the value of isCartShowing.
  showHideCartSpan.textContent = isCartShowing ? 'Hide' : 'Show'; //A ternary expression which checks if isCartShowing is true. If it is, set the textContent to "Hide", otherwise set it to "Show".
  cartContainer.hidden = isCartShowing ? false : true; //A ternary which checks if isCartShowing is true. If it is, set the display property to "block", otherwise set it to "none".
}); //To make the cart visible on the webpage.

clearCartBtn.addEventListener('click', cart.clearCart.bind(cart)); //Add a click event listener to the clearCartBtn. For the callback, pass in cart.clearCart directly. However, doing so will not work, because the context of this will be the clearCartBtn element. Bind the clearCart method to the cart object. By passing cart.clearCart.bind(cart) as the callback.
</script>
</html>